// prisma/schema.prisma

// -- Datasource & Generator
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// -- Core auth models (Lucia-compatible minimal set)

model User {
  id            String   @id @default(cuid())
  email         String   @unique
  emailVerified Boolean  @default(false)
  passwordHash  String   @default("")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Echo participation tracking (micro-echo: 1 echo = 1_000_000)
  balanceEcho        Int @default(0) // stored in micro-echo (uecho)
  participationScore Int @default(0) // stored in micro-echo (uecho)

  sessions     Session[]
  keys         Key[]
  verifyTokens VerifyEmailToken[]
  resetTokens  ResetPasswordToken[] 
  echoLogs     EchoLog[]

  // Referral graph (fixed-once)
  referralCode String? @unique
  referrerId   String?
  referrer     User?   @relation("UserRef", fields: [referrerId], references: [id])
  referrals    User[]  @relation("UserRef")

  @@index([referrerId])
}

model NftMintEvent {
  id          String   @id @default(cuid())
  userId      String?
  wallet      String
  tierId      Int
  quantity    Int      @default(1)
  txSignature String
  network     String
  createdAt   DateTime @default(now())
}

// Key = identity credential (password or OAuth). For password, store hash here.
model Key {
  id             String   @id // recommended format: "providerId:providerUserId"
  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  hashedPassword String? // present for "password" provider
  primary        Boolean  @default(false)
  createdAt      DateTime @default(now())

  @@index([userId])
}

// Session with rolling expiry (active/idle) as 64-bit integers
model Session {
  id            String   @id @default(cuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  activeExpires BigInt
  idleExpires   BigInt
  createdAt     DateTime @default(now())

  @@index([userId])
}

// Email verification token (single-use)
model VerifyEmailToken {
  id         String    @id @default(cuid())
  userId     String
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash  String // sha256 of the raw token
  expiresAt  DateTime
  consumedAt DateTime?
  createdAt  DateTime  @default(now())

  @@unique([tokenHash])
  @@index([userId])
}

// Password reset token (single-use)
model ResetPasswordToken {
  id         String    @id @default(cuid())
  userId     String
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash  String // sha256 of the raw token
  expiresAt  DateTime
  consumedAt DateTime?
  createdAt  DateTime  @default(now())

  @@unique([tokenHash])
  @@index([userId])
}

// (Next steps) 2FA TOTP secret stored encrypted-at-rest (will be added later)
// model TotpSecret { ... }

// (Next steps) Recovery codes stored as hashes (will be added later)
// model RecoveryCode { ... }

// (Next steps) WebAuthn credentials (will be added later)
// model WebAuthnCredential { ... }

model EchoLog {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  kind      String // referral | purchase | activity | bonus | revoke
  action    String // 'kyc_approved', 'nft.base', ...
  amountUe  Int // delta in micro-echo (может быть отрицательным при revoke)
  bucket    String? // резерв под «Банк сокровищ»: 'soul' | 'mind' | 'base' | 'heart'
  sourceId  String? // id покупки/реферала/тикета и т.п.
  refUserId String? // приглашённый пользователь (для referral.*)
  meta      Json? // произвольный контекст (tier, campaign и т.д.)
  dedupeKey String? @unique // для идемпотентности
  qty Int @default(1)

  createdAt DateTime @default(now())

  @@index([userId, kind])
  @@index([action])
  @@index([sourceId])
}