// prisma/schema.prisma

// -- Datasource & Generator
datasource db {
  provider = "postgresql"
}

generator client {
  provider = "prisma-client-js"
}

enum KycStatus {
  none
  pending
  approved
  rejected
}

enum CountryZone {
  green
  grey
  red
}

enum FormSubmissionKind {
  club_pilot
  ambassador
  faq_question
  other
}

enum FormSubmissionStatus {
  new
  in_review
  done
  spam
  archived
}

model User {
  id            String   @id @default(cuid())
  email         String   @unique
  emailVerified Boolean  @default(false)
  passwordHash  String   @default("")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Echo participation tracking (micro-echo: 1 echo = 1_000_000)
  balanceEcho        Int @default(0) // stored in micro-echo (uecho)
  participationScore Int @default(0) // stored in micro-echo (uecho)

  sessions     Session[]
  keys         Key[]
  verifyTokens VerifyEmailToken[]
  resetTokens  ResetPasswordToken[]
  echoLogs     EchoLog[]

  // Referral graph (fixed-once)
  referralCode String? @unique
  referrerId   String?
  referrer     User?   @relation("UserRef", fields: [referrerId], references: [id])
  referrals    User[]  @relation("UserRef")

  // 1:1 profile (создаётся, когда пользователь впервые заполняет профиль)
  profile UserProfile?

  // KYC
  kycStatus       KycStatus        @default(none)
  kycCountryZone  CountryZone?
  kycData         KycData?
  kycUpdatedAt    DateTime?
  kycNote         String?
  formSubmissions FormSubmission[]

  @@index([referrerId])
}

model NftMintEvent {
  createdAt      DateTime @default(now())
  id             String   @id @default(cuid())
  wallet         String
  tierId         Int
  collectorId    String? // AG-MMXXVI-0000-00
  buyerLastName  String?
  buyerFirstName String?
  userId         String?
  quantity       Int      @default(1)
  paidSol        Float    @default(0)
  designChoice   Int? // 1=Tree, 2=Steel (only tierId=0)
  withPhysical   Boolean? // only tierId=2 (Silver)

  // NFT numbering/identifiers 
  tierCode  String? // TR/FE/CU/AG/AU/PT/WS
  serial    Int? // 1..N
  designKey Int? // my scheme

  txSignature String
  network     String
}

// Key = identity credential (password or OAuth). For password, store hash here.
model Key {
  id             String   @id // recommended format: "providerId:providerUserId"
  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  hashedPassword String? // present for "password" provider
  primary        Boolean  @default(false)
  createdAt      DateTime @default(now())

  @@index([userId])
}

// Session with rolling expiry (active/idle) as 64-bit integers
model Session {
  id            String   @id @default(cuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  activeExpires BigInt
  idleExpires   BigInt
  createdAt     DateTime @default(now())

  @@index([userId])
}

// Email verification token (single-use)
model VerifyEmailToken {
  id         String    @id @default(cuid())
  userId     String
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash  String // sha256 of the raw token
  expiresAt  DateTime
  consumedAt DateTime?
  createdAt  DateTime  @default(now())

  @@unique([tokenHash])
  @@index([userId])
}

// Password reset token (single-use)
model ResetPasswordToken {
  id         String    @id @default(cuid())
  userId     String
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash  String // sha256 of the raw token
  expiresAt  DateTime
  consumedAt DateTime?
  createdAt  DateTime  @default(now())

  @@unique([tokenHash])
  @@index([userId])
}

// (Next steps) 2FA TOTP secret stored encrypted-at-rest (will be added later)
// model TotpSecret { ... }

// (Next steps) Recovery codes stored as hashes (will be added later)
// model RecoveryCode { ... }

// (Next steps) WebAuthn credentials (will be added later)
// model WebAuthnCredential { ... }

model EchoLog {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  kind      String // referral | purchase | activity | bonus | revoke
  action    String // 'kyc_approved', 'nft.base', ...
  amountUe  Int // delta in micro-echo (может быть отрицательным при revoke)
  bucket    String? // резерв под «Банк сокровищ»: 'soul' | 'mind' | 'base' | 'heart'
  sourceId  String? // id покупки/реферала/тикета и т.п.
  refUserId String? // приглашённый пользователь (для referral.*)
  meta      Json? // произвольный контекст (tier, campaign и т.д.)
  dedupeKey String? @unique // для идемпотентности
  qty       Int     @default(1)

  createdAt DateTime @default(now())

  @@index([userId, kind])
  @@index([action])
  @@index([sourceId])
}

model UserProfile {
  userId String @id
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  firstName          String
  middleName         String?
  lastName           String
  birthDate          DateTime?
  phone              String?
  countryResidence   String? // ISO country code
  countryCitizenship String? // ISO country code (citizenship / passport)
  countryTax         String? // ISO tax residence
  addressStreet      String?
  addressRegion      String?
  addressCity        String?
  addressPostal      String?
  language           String? // en / ru / et

  // Avatar — храним, например, URL
  photo String?

  // Estonian personal ID code (если countryResidence = "EE")
  isikukood String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model KycData {
  userId String @id
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Base KYC (always collected)
  pepDeclared Boolean?
  pepDetails  String?
  consent     Boolean?

  // Passport (required later for Gold/Platinum, except EE)
  passportNumber    String?
  passportCountry   String?
  passportIssuedAt  DateTime?
  passportExpiresAt DateTime?
  passportIssuer    String?

  // Document upload (temporary: store as dataURL, like avatar)
  documentImage String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model FormSubmission {
  id        String               @id @default(cuid())
  kind      FormSubmissionKind
  status    FormSubmissionStatus @default(new)
  createdAt DateTime             @default(now())
  updatedAt DateTime             @updatedAt

  // Optional link to an authenticated user (if later you allow sending forms from dashboard)
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Contact
  contactName   String?
  email         String?
  phone         String?
  telegram      String?
  preferredLang String? // ru / en / et

  // Location (important for clubs & ambassadors)
  country String? // ISO (e.g., EE)
  region  String?
  city    String?

  // Content
  subject String?
  message String?

  // Form-specific fields (club name, socials, why joined, etc.)
  payload Json?

  // Privacy / consent
  consent        Boolean @default(false)
  privacyVersion String?

  // Source + anti-spam (do NOT store raw IP; store hash)
  sourcePath  String? // e.g. /clubs#apply
  referrer    String?
  utmSource   String?
  utmMedium   String?
  utmCampaign String?

  userAgent String?
  ipHash    String?
  dedupeKey String? @unique

  // Processing
  internalNote String?

  @@index([kind, status])
  @@index([createdAt])
  @@index([email])
  @@index([country, city])
  @@index([userId])
}
